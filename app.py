{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 135,
   "id": "6d5f5a34-8b59-4467-a6ad-73bc289f3dd2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Dependencies\n",
    "from flask import Flask, jsonify\n",
    "import numpy as np\n",
    "from werkzeug.serving import run_simple\n",
    "import sqlalchemy\n",
    "from sqlalchemy.ext.automap import automap_base\n",
    "from sqlalchemy.orm import Session\n",
    "from sqlalchemy import create_engine, func\n",
    "import datetime as dt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 137,
   "id": "3b3ccdf4-37c0-4866-b48f-e972426dd40b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create engine to hawaii.sqlite\n",
    "engine = create_engine(\"sqlite:///Resources/hawaii.sqlite\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 139,
   "id": "6ca41275-0808-4cba-ad72-4a53a3af8f52",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Reflect an existing database into a new model\n",
    "Base = automap_base()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 141,
   "id": "afe9fed3-4cbd-43a0-b073-909f459f54ad",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Reflect the tables\n",
    "Base.prepare(autoload_with=engine)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 143,
   "id": "9ee43d47-307f-4175-860f-8bf3f9aa28b2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Save reference to the table\n",
    "station = Base.classes.station\n",
    "measurement = Base.classes.measurement\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 145,
   "id": "d5b333ae-5d5c-47f8-a6a4-db62cb9e8fe8",
   "metadata": {},
   "outputs": [],
   "source": [
    "app = Flask(__name__)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 147,
   "id": "2781dab0-4698-41a3-8781-84b9fabc431e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define a function which calculates and returns the the date one year from the most recent date\n",
    "def date_prev_year():\n",
    "    # Create the session\n",
    "    session = Session(engine)\n",
    "\n",
    "    # Define the most recent date in the Measurement dataset\n",
    "    # Then use the most recent date to calculate the date one year from the last date\n",
    "    most_recent = session.query(measurement.date).order_by(measurement.date.desc()).first()\n",
    "    one_year = dt.date(2017, 8, 23) - dt.timedelta(days=365)\n",
    "\n",
    "    # Close the session                   \n",
    "    session.close()\n",
    "\n",
    "    # Return the date\n",
    "    return(one_year)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 149,
   "id": "671449dc-fad1-4237-bbf6-dd2af8cedbd5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define what to do when the user hits the homepage\n",
    "@app.route(\"/\")\n",
    "def homepage():\n",
    "    return \"\"\" <h1> Homepage </h1>\n",
    "    <h3> The available routes are: </h3>\n",
    "    <ul>\n",
    "    <br><a href = \"/api/v1.0/precipitation\"> Precipitation</a>: /api/v1.0/precipitation\n",
    "    <br><a href = \"/api/v1.0/stations\"> Stations </a>: /api/v1.0/stations\n",
    "    <br><a href = \"/api/v1.0/tobs\"> TOBS </a>: /api/v1.0/tobs\n",
    "    <br>To retrieve the minimum, average, and maximum temperatures for a specific start date, use /api/v1.0/&ltstart&gt (replace start date in yyyy-mm-dd format)\n",
    "    <br>To retrieve the minimum, average, and maximum temperatures for a specific start-end range, use /api/v1.0/&ltstart&gt/&ltend&gt (replace start and end date in yyyy-mm-dd format)\n",
    "    \"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 151,
   "id": "6b1800dc-0ea9-475c-8b7d-518ee8c85d58",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define what to do when the user hits the precipitation URL\n",
    "@app.route(\"/api/v1.0/precipitation\")\n",
    "def precipitation():\n",
    "    # Create the session\n",
    "    session = Session(engine)\n",
    "\n",
    "    # Query precipitation data from last 12 months from the most recent date from Measurement table\n",
    "    prcp_data = session.query(measurement.date, measurement.prcp).filter(measurement.date >'2016-08-23').all()\n",
    "\n",
    "    # Close the session                   \n",
    "    session.close()\n",
    "\n",
    "    # Create a dictionary from the row data and append to a list of prcp_list\n",
    "    prcp_list = []\n",
    "    for date, prcp in prcp_data:\n",
    "        prcp_dict = {}\n",
    "        prcp_dict[\"date\"] = date\n",
    "        prcp_dict[\"prcp\"] = prcp\n",
    "        prcp_list.append(prcp_dict)\n",
    "\n",
    "    # Return a list of jsonified precipitation data for the previous 12 months \n",
    "    return jsonify(prcp_list)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 153,
   "id": "6c029194-2dee-459b-b263-1d9e9376919b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define what to do when the user hits the station URL\n",
    "@app.route(\"/api/v1.0/stations\")\n",
    "def stations():\n",
    "    # Create the session\n",
    "    session = Session(engine)\n",
    "\n",
    "    # Query station data from the Station dataset\n",
    "    station_data = session.query(station.station).all()\n",
    "\n",
    "    # Close the session                   \n",
    "    session.close()\n",
    "\n",
    "    # Convert list of tuples into normal list\n",
    "    station_list = list(np.ravel(station_data))\n",
    "\n",
    "    # Return a list of jsonified station data\n",
    "    return jsonify(station_list)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 155,
   "id": "b1958ddb-4421-46f6-85b1-4c0ae79ed502",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define what to do when the user hits the URL\n",
    "@app.route(\"/api/v1.0/tobs\")\n",
    "def tobs():\n",
    "    # Create our session\n",
    "    session = Session(engine)\n",
    "\n",
    "    # Query tobs data from last 12 months from the most recent date from Measurement table\n",
    "    tobs_data = session.query(measurement.date, measurement.tobs).filter(measurement.station == 'USC00519281').\\\n",
    "                        filter(measurement.date >'2016-08-23').all()\n",
    "\n",
    "    # Close the session                   \n",
    "    session.close()\n",
    "\n",
    "    # Create a dictionary from the row data and append to a list of tobs_list\n",
    "    tobs_list = []\n",
    "    for date, tobs in tobs_data:\n",
    "        tobs_dict = {}\n",
    "        tobs_dict[\"date\"] = date\n",
    "        tobs_dict[\"tobs\"] = tobs\n",
    "        tobs_list.append(tobs_dict)\n",
    "\n",
    "    # Return a list of jsonified tobs data for the previous 12 months\n",
    "    return jsonify(tobs_list)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 157,
   "id": "2a0655e7-e26e-412b-9698-9827b687ec49",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define what to do when the user hits the URL with a specific start date or start-end range\n",
    "@app.route(\"/api/v1.0/<start>\")\n",
    "@app.route(\"/api/v1.0/<start>/<end>\")\n",
    "def cal_temp(start=None, end=None):\n",
    "    # Create the session\n",
    "    session = Session(engine)\n",
    "    \n",
    "    # Make a list to query (the minimum, average and maximum temperature)\n",
    "    sel=[func.min(measurement.tobs), func.avg(measurement.tobs), func.max(measurement.tobs)]\n",
    "    \n",
    "    # Check if there is an end date then do the task accordingly\n",
    "    if end == None: \n",
    "        # Query the data from start date to the most recent date\n",
    "        start_data = session.query(*sel).\\\n",
    "                            filter(measurement.date >= start).all()\n",
    "        # Convert list of tuples into normal list\n",
    "        start_list = list(np.ravel(start_data))\n",
    "\n",
    "        # Return a list of jsonified minimum, average and maximum temperatures for a specific start date\n",
    "        return jsonify(start_list)\n",
    "    else:\n",
    "        # Query the data from start date to the end date\n",
    "        start_end_data = session.query(*sel).\\\n",
    "                            filter(measurement.date >= start).\\\n",
    "                            filter(measurement.date <= end).all()\n",
    "        # Convert list of tuples into normal list\n",
    "        start_end_list = list(np.ravel(start_end_data))\n",
    "\n",
    "        # Return a list of jsonified minimum, average and maximum temperatures for a specific start-end date range\n",
    "        return jsonify(start_end_list)\n",
    "\n",
    "    # Close the session                   \n",
    "    session.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "30d6325a-a734-441f-8088-5e486a58d9db",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\n",
      " * Running on http://localhost:5002\n",
      "Press CTRL+C to quit\n",
      "127.0.0.1 - - [09/Sep/2024 20:57:49] \"GET / HTTP/1.1\" 200 -\n",
      "127.0.0.1 - - [09/Sep/2024 20:57:50] \"GET /api/v1.0/stations HTTP/1.1\" 200 -\n",
      "/var/folders/q5/w3sfn0dn6xxfh2vjt46l5vym0000gp/T/ipykernel_47399/2162776900.py:9: SAWarning: SELECT statement has a cartesian product between FROM element(s) \"measurement\" and FROM element \"measurement\".  Apply join condition(s) between each element to resolve.\n",
      "  filter(measurement.date >'2016-08-23').all()\n",
      "[2024-09-09 20:57:54,626] ERROR in app: Exception on /api/v1.0/tobs [GET]\n",
      "Traceback (most recent call last):\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py\", line 1967, in _exec_single_context\n",
      "    self.dialect.do_execute(\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/default.py\", line 924, in do_execute\n",
      "    cursor.execute(statement, parameters)\n",
      "sqlite3.OperationalError: ambiguous column name: measurement.date\n",
      "\n",
      "The above exception was the direct cause of the following exception:\n",
      "\n",
      "Traceback (most recent call last):\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/flask/app.py\", line 1473, in wsgi_app\n",
      "    response = self.full_dispatch_request()\n",
      "               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/flask/app.py\", line 882, in full_dispatch_request\n",
      "    rv = self.handle_user_exception(e)\n",
      "         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/flask/app.py\", line 880, in full_dispatch_request\n",
      "    rv = self.dispatch_request()\n",
      "         ^^^^^^^^^^^^^^^^^^^^^^^\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/flask/app.py\", line 865, in dispatch_request\n",
      "    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\n",
      "           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
      "  File \"/var/folders/q5/w3sfn0dn6xxfh2vjt46l5vym0000gp/T/ipykernel_47399/2162776900.py\", line 9, in tobs\n",
      "    filter(measurement.date >'2016-08-23').all()\n",
      "                                           ^^^^^\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/orm/query.py\", line 2673, in all\n",
      "    return self._iter().all()  # type: ignore\n",
      "           ^^^^^^^^^^^^\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/orm/query.py\", line 2827, in _iter\n",
      "    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(\n",
      "                                                  ^^^^^^^^^^^^^^^^^^^^^\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/orm/session.py\", line 2351, in execute\n",
      "    return self._execute_internal(\n",
      "           ^^^^^^^^^^^^^^^^^^^^^^^\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/orm/session.py\", line 2236, in _execute_internal\n",
      "    result: Result[Any] = compile_state_cls.orm_execute_statement(\n",
      "                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/orm/context.py\", line 293, in orm_execute_statement\n",
      "    result = conn.execute(\n",
      "             ^^^^^^^^^^^^^\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py\", line 1418, in execute\n",
      "    return meth(\n",
      "           ^^^^^\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/sql/elements.py\", line 515, in _execute_on_connection\n",
      "    return connection._execute_clauseelement(\n",
      "           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py\", line 1640, in _execute_clauseelement\n",
      "    ret = self._execute_context(\n",
      "          ^^^^^^^^^^^^^^^^^^^^^^\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py\", line 1846, in _execute_context\n",
      "    return self._exec_single_context(\n",
      "           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py\", line 1986, in _exec_single_context\n",
      "    self._handle_dbapi_exception(\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py\", line 2353, in _handle_dbapi_exception\n",
      "    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/base.py\", line 1967, in _exec_single_context\n",
      "    self.dialect.do_execute(\n",
      "  File \"/opt/anaconda3/lib/python3.12/site-packages/sqlalchemy/engine/default.py\", line 924, in do_execute\n",
      "    cursor.execute(statement, parameters)\n",
      "sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) ambiguous column name: measurement.date\n",
      "[SQL: SELECT measurement.date AS measurement_date, measurement.tobs AS measurement_tobs \n",
      "FROM measurement, measurement \n",
      "WHERE measurement.station = ? AND measurement.date > ?]\n",
      "[parameters: ('USC00519281', '2016-08-23')]\n",
      "(Background on this error at: https://sqlalche.me/e/20/e3q8)\n",
      "127.0.0.1 - - [09/Sep/2024 20:57:54] \"GET /api/v1.0/tobs HTTP/1.1\" 500 -\n",
      "127.0.0.1 - - [09/Sep/2024 20:57:57] \"GET /api/v1.0/precipitation HTTP/1.1\" 200 -\n"
     ]
    }
   ],
   "source": [
    "# Define main branch \n",
    "if __name__ == '__main__':\n",
    "    run_simple('localhost', 5002, app, use_reloader=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e922dc64-fc65-4c42-9ece-44bf6ccf9e39",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e2d1c11a-a206-4d8e-91b9-7080f6915406",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d9038b6f-02f6-48f6-a1bb-f32269f925ad",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
